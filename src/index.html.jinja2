<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{{ args.project_name }} Generator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
    <style>
        #pane-left {
            position: absolute;
            height: 100%;
            width: 60%;
        }
        #controls {
            position: absolute;
            padding: 1em;
            top: 0;
        }
        #model {
            height: 100%;
            width: 100%;
        }
        #pane-right {
            position: absolute;
            right: 0;
            height: 100%;
            width: 40%;
            overflow: scroll;
            padding-right: 1em;
        }
        @media only screen and (max-width: 992px) {
            #pane-left {
                position: relative;
                height: auto;
                width: 100vw;
            }
            #controls {
                position: relative;
            }
            #model {
                height: 80vh;
                width: 100vw;
            }
            #pane-right {
                position: relative;
                height: auto;
                width: 100%;
                overflow: auto;
            }
        }
    </style>
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"></script>
    <script type="module">
        const renderButton = document.getElementById("render");
        const renderState = document.getElementById("render-state");
        const downloadStlButton = document.getElementById("download-stl");
        const renderError = document.getElementById("render-error");
        const renderErrorSummary = document.getElementById("render-error-summary");
        const renderErrorLog = document.getElementById("render-error-log");
        const renderErrorCopy = document.getElementById("render-error-copy");
        const worker = new Worker("./{{ worker_script_name }}", {type: "module"})
        const SCAD_INPUT = {{ input | json_dump }};
        const ADDITIONAL_PARAM_NAMES = [
            {% for param in additional_parameters | default([]) %}
                {{ param['name'] | json_dump }},
            {% endfor %}
        ];
        function setRenderErrorVisible(visible) {
            if (visible) {
                renderError.classList.remove("d-none");
            } else {
                renderError.classList.add("d-none");
            }
        }

        function clearRenderError() {
            renderErrorSummary.textContent = "";
            renderErrorLog.textContent = "";
            setRenderErrorVisible(false);
        }

        function showRenderError({summary, log}) {
            renderErrorSummary.textContent = summary || "Render failed";
            renderErrorLog.textContent = log || "";
            setRenderErrorVisible(true);
        }

        worker.addEventListener("error", (event) => {
            console.error("Worker script error", event)
            showRenderError({
                summary: "Worker crashed while rendering",
                log: String(event && event.message ? event.message : event),
            })
            setRendering(false);
        })
        worker.addEventListener("messageerror", (event) => {
            console.error("Worker message error", event)
            showRenderError({
                summary: "Worker message error",
                log: String(event && event.message ? event.message : event),
            })
            setRendering(false);
        })
        let lastResult = null;
        worker.addEventListener("message", (event) => {
            if (!event.data || typeof event.data !== "object") {
                return;
            }
            if (event.data.type === "ok") {
                lastResult = event.data;
                document.getElementById("model").src = URL.createObjectURL(new Blob([event.data.glb], {type: "model/gltf-binary"}));
                clearRenderError();
                setRendering(false);
            }
            if (event.data.type === "error") {
                console.error("Worker error", event.data);
                const summary = event.data && event.data.error ? String(event.data.error) : "Render failed";
                const parts = [];
                if (event.data && event.data.log) {
                    parts.push(String(event.data.log));
                }
                if (event.data && event.data.stack) {
                    const stack = String(event.data.stack);
                    if (stack.trim()) {
                        parts.push("\n---\n" + stack);
                    }
                }
                showRenderError({summary, log: parts.join("\n")});
                setRendering(false);
            }
        });

        const defaultCustomization = {
            {% for param in metadata["parameters"] + (additional_parameters | default([])) -%}
                "{{ param["name"] }}":
                {%- if param["type"] == "boolean" %}{% if param["initial"] %}true{% else %}false{% endif %}
                {%- elif param["type"] == "string" %}"{{ param["initial"] }}"
                {%- else %}{{ param["initial"] }}{% endif %},
            {% endfor %}
        };
        const currentCustomization = JSON.parse(JSON.stringify(defaultCustomization));

        function jsonEqual(a, b) {
            if (a === undefined && b === undefined) {
                return true;
            }
            return JSON.stringify(a) === JSON.stringify(b);
        }

        const DEBUG_CUSTOMIZATION_HASH = false;

        function computeChangedCustomization() {
            const changed = {};
            for (const [k, defaultValue] of Object.entries(defaultCustomization)) {
                if (!jsonEqual(currentCustomization[k], defaultValue)) {
                    changed[k] = currentCustomization[k];
                }
            }
            return changed;
        }

        function resetCurrentCustomizationToDefault() {
            for (const [k, v] of Object.entries(defaultCustomization)) {
                currentCustomization[k] = JSON.parse(JSON.stringify(v));
            }
        }

        function base64EncodeUtf8(text) {
            const bytes = new TextEncoder().encode(text);
            let binary = "";
            for (const b of bytes) {
                binary += String.fromCharCode(b);
            }
            return btoa(binary);
        }

        function base64DecodeUtf8(text) {
            const binary = atob(text);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return new TextDecoder().decode(bytes);
        }

        function updateUrlFromCustomization() {
            const changed = computeChangedCustomization();
            const json = Object.keys(changed).length === 0 ? "" : JSON.stringify(changed);
            // URL hash must stay URL-safe even though we store base64.
            const hash = json === "" ? "" : encodeURIComponent(base64EncodeUtf8(json));
            const url = new URL(window.location.href);
            url.hash = hash === "" ? "" : "#" + hash;

            if (url.href === window.location.href) {
                return;
            }

            if (DEBUG_CUSTOMIZATION_HASH) {
                console.log("updateUrlFromCustomization", {changed, hash: url.hash});
            }

            navigation.navigate(url.href, {
                history: "replace",
                state: navigation.currentEntry.getState() ?? null,
                // Used to avoid re-rendering on purely programmatic URL sync.
                info: {type: "customization-sync"},
            });
        }

        function applyCustomizationToInputs() {
            for (const input of document.querySelectorAll(".customizer")) {
                const name = input.getAttribute("attr-name");
                const index = input.getAttribute("attr-index");
                const value = index !== null ? currentCustomization?.[name]?.[index] : currentCustomization?.[name];
                if (value === undefined) {
                    continue;
                }

                if (input.type === "checkbox") {
                    input.checked = !!value;
                } else if (input.type === "select-one") {
                    // Try to preserve the exact option value string (e.g. "1.0" vs "1").
                    let found = false;
                    for (const option of input.options) {
                        try {
                            if (jsonEqual(JSON.parse(option.value), value)) {
                                input.value = option.value;
                                found = true;
                                break;
                            }
                        } catch (e) {
                            // Ignore unparsable option values.
                        }
                    }
                    if (!found) {
                        if (DEBUG_CUSTOMIZATION_HASH) {
                            console.warn("No matching <option> for value", {name, value});
                        }
                        input.value = JSON.stringify(value);
                    }
                } else {
                    input.value = String(value);
                }
            }
        }

        function restoreCustomizationFromHash(hashString, {normalizeUrl = false} = {}) {
            resetCurrentCustomizationToDefault();
            if (!hashString || hashString.length <= 1) {
                applyCustomizationToInputs();
                if (normalizeUrl) {
                    updateUrlFromCustomization();
                }
                return;
            }

            let customizationFromUrl;
            try {
                customizationFromUrl = JSON.parse(base64DecodeUtf8(decodeURIComponent(hashString.slice(1))));
            } catch (e) {
                console.warn("Failed to parse customization from URL hash", e);
                applyCustomizationToInputs();
                if (normalizeUrl) {
                    updateUrlFromCustomization();
                }
                return;
            }

            if (!customizationFromUrl || typeof customizationFromUrl !== "object" || Array.isArray(customizationFromUrl)) {
                applyCustomizationToInputs();
                if (normalizeUrl) {
                    updateUrlFromCustomization();
                }
                return;
            }

            for (const [k, v] of Object.entries(customizationFromUrl)) {
                if (k in defaultCustomization) {
                    currentCustomization[k] = v;
                }
            }

            applyCustomizationToInputs();
            if (normalizeUrl) {
                updateUrlFromCustomization();
            }
        }

        for (const input of document.querySelectorAll(".customizer")) {
            const name = input.getAttribute("attr-name");
            const index = input.getAttribute("attr-index");
            input.addEventListener("change", function () {
                let value;
                if (this.type === "checkbox") {
                    value = this.checked;
                } else if (this.type === "select-one") {
                    value = JSON.parse(this.value);
                } else if (this.type === "number") {
                    value = this.valueAsNumber;
                } else {
                    value = this.value;
                }
                if (index !== null) {
                    currentCustomization[name][index] = value;
                } else {
                    currentCustomization[name] = value;
                }

                updateUrlFromCustomization();
            });
        }

        function setRendering(rendering) {
            renderButton.disabled = rendering;
            downloadStlButton.disabled = rendering;
            if (rendering) {
                lastResult = null;
                renderState.classList.remove("d-none");
            } else {
                renderState.classList.add("d-none");
            }
        }

        function startRender() {
            clearRenderError();
            setRendering(true);
            worker.postMessage({
                type: "render",
                input: SCAD_INPUT,
                customization: currentCustomization,
                additionalParamNames: ADDITIONAL_PARAM_NAMES,
            });
        }

        renderErrorCopy.addEventListener("click", async () => {
            const text = renderErrorLog.textContent || "";
            try {
                await navigator.clipboard.writeText(text);
            } catch (e) {
                console.warn("Failed to copy log to clipboard", e);
            }
        });

        navigation.addEventListener("navigate", (event) => {
            if (!event.canIntercept) {
                return;
            }

            const destination = new URL(event.destination.url);
            const current = new URL(window.location.href);
            const isSameDocument = destination.origin === current.origin &&
                destination.pathname === current.pathname &&
                destination.search === current.search;
            if (!isSameDocument) {
                return;
            }

            // Prevent the browser from doing default hash scrolling/focus reset: our hash isn't an anchor.
            event.intercept({
                scroll: "manual",
                focusReset: "manual",
                handler: async () => {
                    if (event.info && event.info.type === "customization-sync") {
                        return;
                    }

                    restoreCustomizationFromHash(destination.hash);
                    startRender();
                },
            });
        });

        window.addEventListener("load", () => {
            restoreCustomizationFromHash(window.location.hash, {normalizeUrl: true});
            startRender();
        });
        renderButton.addEventListener("click", function () {
            if (!this.disabled) {
                startRender();
            }
        });
        downloadStlButton.addEventListener("click", function () {
            if (lastResult != null) {
                const link = document.createElement("a");
                link.href = URL.createObjectURL(new Blob([lastResult.stl], {type: "application/octet-stream"}));
                link.download = "{{ args.export_filename_prefix }}.stl";
                document.body.appendChild(link);
                link.click();
                link.remove();
            }
        });
    </script>
</head>
<body>
<div id="pane-left">
    <model-viewer id="model" camera-controls interaction-prompt="none"></model-viewer>
    <div id="controls">
        <button id="render" type="button" class="btn btn-primary">Render<span id="render-state" class="d-none">ingâ€¦ <span
                class="spinner-border spinner-border-sm" aria-hidden="true"></span></span></button>
        <button id="download-stl" type="button" class="btn btn-secondary">Save STL</button>
        <div id="render-error" class="alert alert-danger mt-2 d-none" role="alert">
            <div class="d-flex align-items-center justify-content-between gap-2 flex-wrap">
                <div>
                    <strong>Render failed.</strong>
                    <span id="render-error-summary"></span>
                </div>
                <div class="d-flex gap-2">
                    <button type="button" class="btn btn-sm btn-outline-danger" data-bs-toggle="modal" data-bs-target="#render-error-modal">Show log</button>
                </div>
            </div>
        </div>
    </div>
</div>
<div id="pane-right" class="row">
    <p>
        This is the model generator for <a href="{{ args.project_uri }}">{{ args.project_name }}</a>.
        Any changes you make are saved in the URL, so you can share that URL or create a bookmark to keep those changes around.
        {% if generators and generators|length > 1 %}
            Other generators:
            {% for g in generators %}
                {% if g.output_html == output_html %}
                    <strong>{{ g.label }}</strong>{% if not loop.last %},{% endif %}
                {% else %}
                    <a href="{{ g.link }}">{{ g.label }}</a>{% if not loop.last %},{% endif %}
                {% endif %}
            {% endfor %}
        {% endif %}
    </p>
    {% macro render_param(param) %}
        {% set pid = "parameter_" + param['name'] %}
        <div class="col-6 text-end mb-2">
            <label for="{{ pid }}">{{ param['name'].replace('_', ' ') }}<br><span
                    class="form-text">{{ param['caption'] }}</span></label>
        </div>
        <div class="col-6">
            {% if param['type'] == 'number' and param['initial'] is iterable %}
                <div class="input-group">
                    {% for initial in param['initial'] %}
                        <input class="form-control customizer" type="number"{% if loop.index0 == 0 %}
                               id="{{ pid }}"{% endif %} value="{{ initial }}" attr-name="{{ param['name'] }}"
                               attr-index="{{ loop.index0 }}" autocomplete="off">
                    {% endfor %}
                </div>
            {% elif param['options'] %}
                <select class="form-control customizer" id="{{ pid }}" attr-name="{{ param['name'] }}" autocomplete="off">
                    {% for option in param['options'] %}
                        <option value='{{ option['value'] | json_dump }}'
                                {% if option['value'] == param['initial'] %}selected{% endif %}>{{ option['name'] }}</option>
                    {% endfor %}
                </select>
            {% elif param['type'] == 'number' %}
                <input class="form-control customizer" type="number" id="{{ pid }}" value="{{ param['initial'] }}"
                       attr-name="{{ param['name'] }}" autocomplete="off">
            {% elif param['type'] == 'boolean' %}
                <input class="form-check-input customizer" type="checkbox" id="{{ pid }}"
                       {% if param['initial'] %}checked{% endif %} attr-name="{{ param['name'] }}" autocomplete="off">
            {% else %}
                <input class="form-control customizer" type="text" id="{{ pid }}" value="{{ param['initial'] }}"
                       attr-name="{{ param['name'] }}" autocomplete="off">
            {% endif %}
        </div>
    {% endmacro %}

    {% set state = namespace(current_group=None) %}
    {% for param in metadata["parameters"] + (additional_parameters | default([])) %}
        {% set group = param.get('group') %}
        {% if group and group != state.current_group %}
            {% set state.current_group = group %}
            <h3>{{ group }}</h3>
        {% endif %}
        {{ render_param(param) }}
    {% endfor %}
</div>

<div class="modal fade" id="render-error-modal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h1 class="modal-title fs-5">Render Log</h1>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <pre id="render-error-log" class="bg-light border rounded p-2" style="white-space: pre-wrap;"></pre>
            </div>
            <div class="modal-footer">
                <button id="render-error-copy" type="button" class="btn btn-outline-secondary">Copy</button>
                <button type="button" class="btn btn-primary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI"
        crossorigin="anonymous"></script>
</body>
</html>
