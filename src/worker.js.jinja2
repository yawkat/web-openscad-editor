import OpenSCAD from "./openscad-wasm/openscad.js"
import * as THREE from "https://esm.sh/three@0.160.0"
import { STLLoader } from "https://esm.sh/three@0.160.0/examples/jsm/loaders/STLLoader.js"
import { GLTFExporter } from "https://esm.sh/three@0.160.0/examples/jsm/exporters/GLTFExporter.js"

console.log("Worker started")

let runQueue = Promise.resolve()
// OpenSCAD's WASM build aborts its runtime after a render.
// Create a fresh instance for each render.

const INPUTS = {{ inputs | json_dump }}

function base64ToUint8Array(base64) {
    const binary = atob(base64)
    const bytes = new Uint8Array(binary.length)
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i)
    }
    return bytes
}

function uint8ArrayToArrayBuffer(bytes) {
    return bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength)
}

async function stlBytesToGlb(stlBytes) {
    const geometry = new STLLoader().parse(uint8ArrayToArrayBuffer(stlBytes))
    if (!geometry.getAttribute("normal")) {
        geometry.computeVertexNormals()
    }

    const material = new THREE.MeshStandardMaterial({
        color: 0x9aa3ad,
        metalness: 0.8,
        roughness: 0.3,
        flatShading: true,
        vertexColors: geometry.hasAttribute("color"),
    })
    const mesh = new THREE.Mesh(geometry, material)
    // OpenSCAD uses mm; glTF uses meters.
    mesh.scale.setScalar(0.001)

    const scene = new THREE.Scene()
    scene.add(mesh)

    // Add a few basic lights so the exported GLB shades nicely even without an HDR environment.
    const lightA = new THREE.DirectionalLight(0xD60270, 5)
    lightA.position.set(1000, 1000, 1000)
    scene.add(lightA)
    lightA.lookAt(0, 0, 0)
    const lightB = new THREE.DirectionalLight(0x0038A8, 5)
    lightB.position.set(-1000, 1000, 1000)
    lightB.lookAt(0, 0, 0)
    scene.add(lightB)

    return await new Promise((resolve, reject) => {
        const exporter = new GLTFExporter()
        exporter.parse(
            scene,
            (result) => {
                if (result instanceof ArrayBuffer) {
                    resolve(result)
                } else {
                    reject(new Error("Expected binary glTF (ArrayBuffer)"))
                }
            },
            (error) => reject(error),
            { binary: true },
        )
    })
}

async function createInstance() {
    const instance = await OpenSCAD({
        noInitialRun: true,
        print: console.log,
        printErr: console.log,
    })
    {% for k, v in fs.items() %}
    {
        const data = base64ToUint8Array("{{ v }}")
        console.log("Loading {{ k }} (" + data.length + " bytes)")
        const parent = "{{ k }}".substring(0, "{{ k }}".lastIndexOf("/"))
        if (parent) {
            instance.FS.mkdirTree(parent)
        }
        instance.FS.writeFile("{{ k }}", data)
    }
    {% endfor %}
    return instance
}

function normalizeInputPath(input) {
    const inputPath = String(input || "")
    if (!inputPath) {
        throw new Error("Missing input SCAD path")
    }
    const normalized = inputPath.startsWith("/") ? inputPath : "/" + inputPath
    if (!INPUTS.includes(normalized)) {
        throw new Error("Unknown input SCAD path: " + normalized)
    }
    return normalized
}

async function renderOnce({ input, customization, additionalParamNames }) {
    const instance = await createInstance()
    const inputPath = normalizeInputPath(input)

    const additionalParamNameSet = new Set(
        Array.isArray(additionalParamNames)
            ? additionalParamNames.filter((x) => typeof x === "string")
            : [],
    )

    const stringifiedParameters = {}
    const additionalDefinitions = []
    for (const [k, v] of Object.entries(customization)) {
        if (additionalParamNameSet.has(k)) {
            // -D expects an OpenSCAD expression; JSON happens to be close enough for our value types.
            additionalDefinitions.push(`${k}=${JSON.stringify(v)}`)
        } else {
            // Parameter set files use unquoted strings for string parameters.
            stringifiedParameters[k] = typeof v === "string" ? v : JSON.stringify(v)
        }
    }
    console.log("Parameters:", stringifiedParameters)
    console.log("Additional -D:", additionalDefinitions)
    instance.FS.writeFile(
        "/parameters.json",
        JSON.stringify({
            fileFormatVersion: 1,
            parameterSets: {
                single: stringifiedParameters,
            },
        }),
    )

    const output = "/output.stl"
    try {
        instance.FS.unlink(output)
    } catch (e) {
        // ignore
    }
    const args = [
        inputPath,
        "-o",
        output,
        "--export-format=binstl",
        "-p",
        "/parameters.json",
        "-P",
        "single",
    ]
    for (const def of additionalDefinitions) {
        args.push("-D", def)
    }
    instance.callMain(args)
    const stlBytes = instance.FS.readFile(output)

    const glb = await stlBytesToGlb(stlBytes)
    self.postMessage({
        type: "ok",
        glb: glb,
        stl: stlBytes
    })
}

self.addEventListener("message", (event) => {
    const msg = event && event.data
    if (!msg || typeof msg !== "object") {
        return
    }

    // Serialize OpenSCAD runs to avoid concurrent FS/wasm access.
    runQueue = runQueue.then(async () => {
        if (msg.type !== "render") {
            return
        }
        await renderOnce({
            input: msg.input,
            customization: msg.customization,
            additionalParamNames: msg.additionalParamNames,
        })
    })
    runQueue.catch((e) => {
        console.error(e);
        self.postMessage({
            type: "error",
            error: String(e && e.message ? e.message : e),
            stack: String(e && e.stack ? e.stack : ""),
        })
    })
})
